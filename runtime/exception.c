#include "exception.h"
#include "membar.h"
#include "common.h"
#include "tls.h"
#include "sched.h"

void increment_exception_pointer(__cilkrts_worker *const ws, 
				 __cilkrts_worker *const victim_ws, 
				 Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT(cl->status == CLOSURE_RUNNING);

  if(victim_ws->exc != EXCEPTION_INFINITY) {
    ++(victim_ws->exc);
    /* make sure the exception is visible, before we continue */
    Cilk_fence();
  }
}

void decrement_exception_pointer(__cilkrts_worker *const ws, 
				 __cilkrts_worker *const victim_ws, 
				 Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT(cl->status == CLOSURE_RUNNING);

  if(victim_ws->exc != EXCEPTION_INFINITY)
    --(victim_ws->exc);
}

void reset_exception_pointer(__cilkrts_worker *const ws, Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT((cl->frame == NULL) || 
	      (cl->frame->worker == ws) || 
	      (cl == ws->g->invoke_main && 
	       cl->frame->worker == (__cilkrts_worker *) NOBODY) );

  ws->exc = ws->head;
}

void signal_immediate_exception_to_all(__cilkrts_worker *const ws) {

    int i, active_size = ws->g->active_size;
    __cilkrts_worker *curr_ws;

    for(i=0; i<active_size; i++) {
        curr_ws = ws->g->workers[i];
        curr_ws->exc = EXCEPTION_INFINITY;
    }
    // make sure the exception is visible, before we continue
    Cilk_fence();
}

/* 
 * ANGE: this is called from the user code (generated by compiler in cilkc)
 *       if Cilk_cilk2c_pop_check returns TRUE (i.e. E >= T).  Two 
 *       possibilities: 1. someone stole the last frame from this worker, 
 *       hence pop_check fails (E >= T) when child returns.  2. Someone 
 *       invokes signal_immediate_exception with the closure currently 
 *       running on the worker's deque.  This is only possible with abort.
 *       In Cilk-M, we use abort only if user invokes Cilk_exit to quit the
 *       program early.
 *
 *       If this function returns 1, the user code then calls 
 *       Cilk_cilk2c_before_return, which destroys the shadow frame and
 *       return back to caller. 
 */
void Cilk_exception_handler() {

    Closure *t;

    __cilkrts_worker *ws = __cilkrts_get_tls_worker();

    //----- EVENT_EXCEPTION

    deque_lock_self(ws);
    t = deque_peek_bottom(ws, ws->self);

    CILK_ASSERT(t);
    
    Closure_lock(ws, t);

    __cilkrts_alert(ALERT_EXCEPT, "[%d]: (Cilk_exception_handler) closure %p!\n", ws->self, t);

    /* ANGE: resetting the E pointer since we are handling the exception */
    reset_exception_pointer(ws, t);

    CILK_ASSERT(t->status == CLOSURE_RUNNING ||
                    // for during abort process
                    t->status == CLOSURE_RETURNING);

    if( ws->head > ws->tail ) {
        //----- EVENT_EXCEPTION_STEAL // ANGE: this is a steal
      __cilkrts_alert(ALERT_EXCEPT, "[%d]: (Cilk_exception_handler) this is a steal!\n", ws->self);

        if(t->status == CLOSURE_RUNNING) {
            CILK_ASSERT(Closure_has_children(t) == 0);
            t->status = CLOSURE_RETURNING;
        }

    } else { // not steal, not abort; false alarm
        //----- EVENT_EXCEPTION_OTHER
        Closure_unlock(ws, t);
        deque_unlock_self(ws);

        return;
    }

    

    // MAK: FIBER-THE CASE
    // Execute left-holder logic for stacks.
    if (t->left_sib || t->spawn_parent->fiber_child) {
      // Case where we are not the leftmost stack.
      __cilkrts_alert(ALERT_FIBER, "[%d]: (Cilk_exception_handler) we are not the leftmost stack.\n", ws->self);
      CILK_ASSERT(t->spawn_parent->fiber_child != t->fiber);

      // Remember any fiber we need to free in the worker.
      // After we jump into the runtime, we will actually do the
      // free.
      ws->l->fiber_to_free = t->fiber;
    } else {
      // We are leftmost, pass stack/fiber up to parent.
      __cilkrts_alert(ALERT_FIBER, "[%d]: (Cilk_exception_handler) we are the leftmost stack!\n", ws->self);
      // Thus, no stack/fiber to free.
      t->spawn_parent->fiber_child = t->fiber;
      ws->l->fiber_to_free = NULL;
    }

    t->fiber = NULL;

    Closure_unlock(ws, t);
    deque_unlock_self(ws);
    longjmp_to_runtime(ws); // NOT returning back to user code
}
