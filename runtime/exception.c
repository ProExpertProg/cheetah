#include "exception.h"
#include "membar.h"
#include "common.h"

void increment_exception_pointer(__cilkrts_worker *const ws, 
				 __cilkrts_worker *const victim_ws, 
				 Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT(cl->status == CLOSURE_RUNNING);

  if(victim_ws->exc != EXCEPTION_INFINITY) {
    ++(victim_ws->exc);
    /* make sure the exception is visible, before we continue */
    Cilk_fence();
  }
}

void decrement_exception_pointer(__cilkrts_worker *const ws, 
				 __cilkrts_worker *const victim_ws, 
				 Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT(cl->status == CLOSURE_RUNNING);

  if(victim_ws->exc != EXCEPTION_INFINITY)
    --(victim_ws->exc);
}

void reset_exception_pointer(__cilkrts_worker *const ws, Closure *cl) {

  Closure_assert_ownership(ws, cl);
  CILK_ASSERT((cl->frame == NULL) || 
	      (cl->frame->worker == ws) || 
	      (cl == ws->g->invoke_main && 
	       cl->frame->worker == (__cilkrts_worker *) NOBODY) );

  ws->exc = ws->head;
}


void signal_immediate_exception_to_all(__cilkrts_worker *const ws) {

    int i, active_size = ws->g->active_size;
    __cilkrts_worker *curr_ws;

    for(i=0; i<active_size; i++) {
        curr_ws = ws->g->workers[i];
        curr_ws->exc = EXCEPTION_INFINITY;
    }
    // make sure the exception is visible, before we continue
    Cilk_fence();
}

/* 
 * ANGE: this is called from the user code (generated by compiler in cilkc)
 *       if Cilk_cilk2c_pop_check returns TRUE (i.e. E >= T).  Two 
 *       possibilities: 1. someone stole the last frame from this worker, 
 *       hence pop_check fails (E >= T) when child returns.  2. Someone 
 *       invokes signal_immediate_exception with the closure currently 
 *       running on the worker's deque.  This is only possible with abort.
 *       In Cilk-M, we use abort only if user invokes Cilk_exit to quit the
 *       program early.
 *
 *       If this function returns 1, the user code then calls 
 *       Cilk_cilk2c_before_return, which destroys the shadow frame and
 *       return back to caller. 
 */
void Cilk_exception_handler() {

    Closure *t;
    int res = 0;

    __cilkrts_worker *ws = __cilkrts_get_tls_worker();

    //----- EVENT_EXCEPTION

    deque_lock_self(ws);
    t = deque_peek_bottom(ws, ws->self);

    CILK_ASSERT(t);
    
    Closure_lock(ws, t);

    /* ANGE: resetting the E pointer since we are handling the exception */
    reset_exception_pointer(ws, t);

    CILK_ASSERT(t->status == CLOSURE_RUNNING ||
                    // for during abort process
                    t->status == CLOSURE_RETURNING);

    if( ws->head > ws->tail ) {
        //----- EVENT_EXCEPTION_STEAL // ANGE: this is a steal

        if(t->status == CLOSURE_RUNNING) {
            CILK_ASSERT(Closure_has_children(t) == 0);
            t->status = CLOSURE_RETURNING;
        }

    } else { // not steal, not abort; false alarm
        //----- EVENT_EXCEPTION_OTHER
        Closure_unlock(ws, t);
        deque_unlock_self(ws);

        return;
    }

    Closure_unlock(ws, t);
    deque_unlock_self(ws);
    goBackToRuntime(ws); // NOT returning back to user code
}
