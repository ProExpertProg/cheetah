struct local_state  /* COMMON_PORTABLE */
{
    /** This value should be in the first field in any local_state */
#   define WORKER_MAGIC_0 ((ls_magic_t)0xe0831a4a940c60b8ULL)

    /**
     * Should be WORKER_MAGIC_0 or the local_state has been corrupted
     * This magic field is shared because it is read on lock acquisitions.
     *
     * [shared read-only]
     */
    ls_magic_t worker_magic_0;

    /**
     * Mutex used to serialize access to the local_state
     * Synchronization field. [shared read/write]
     */
    struct mutex lock;

    /**
     * Flag that indicates that the worker is interested in grabbing
     * LOCK, and thus thieves should leave the worker alone.
     * Written only by self, may be read by others.
     *
     * Synchronization field.  [shared read/write]
     */
    int do_not_steal;

    /**
     * Lock that all thieves grab in order to compete for the right
     * to disturb this worker.
     *
     * Synchronization field. [shared read/write]
     */
    struct mutex steal_lock;

    /**
     * Full frame that the worker is working on.
     *
     * While a worker w is executing, a thief may change
     * w->l->frame_ff (on a successful steal) after acquiring w's
     * lock.
     *
     * Unlocked accesses to w->l->frame_ff are safe (by w itself) when
     * w's deque is empty, or when stealing from w has been disabled.
     *
     * [shared read/write]
     */
    struct full_frame *frame_ff;

    /**
     * Full frame that the worker will be working on next
     *
     * This field is normally local for a worker w.  Another worker v
     * may modify w->l->next_frame_ff, however, in the special case
     * when v is returning a frame to a user thread w since w is the
     * team leader.
     *
     * [shared read/write]
     */
    struct full_frame *next_frame_ff;

    /**
     * This is set iff this is a WORKER_USER and there has been a steal.  It
     * points to the first frame that was stolen since the team was last fully
     * sync'd.  Only this worker may continue past a sync in this function.
     *
     * This field is set by a thief for a victim that is a user
     * thread, while holding the victim's lock.
     * It can be cleared without a lock by the worker that will
     * continue exuecting past the sync.
     *
     * [shared read/write]
     */
    struct full_frame *last_full_frame;

    /**
     * Lazy task queue of this worker - an array of pointers to stack frames.
     *
     * Read-only because deques are a fixed size in the current
     * implementation.
     *
     * @note This field is 64-byte aligned because it is the first in
     * the group of local fields.  We want this group to fall on a
     * different cache line from the previous group, which is shared
     * read-only.
     *
     * [local read-only]
     */
    __attribute__((aligned(64)))
    __cilkrts_stack_frame **ltq;

    /**
     * Pool of fibers waiting to be reused.
     * [local read/write]
     */
    cilk_fiber_pool fiber_pool;

    /**
     * The fiber for the scheduling stacks.
     * [local read/write]
     */
    cilk_fiber* scheduling_fiber;

    /**
     * State of the random number generator
     * 
     * [local read/write]
     */
    unsigned rand_seed;

    /**
     * Function to execute after transferring onto the scheduling stack.
     *
     * [local read/write]
     */
    scheduling_stack_fcn_t post_suspend;

    /**
     * __cilkrts_stack_frame we suspended when we transferred onto the
     * scheduling stack.    
     *
     * [local read/write]
     */
    __cilkrts_stack_frame *suspended_stack;

    /**
     * cilk_fiber that should be freed after returning from a
     *  spawn with a stolen parent or after stalling at a sync.

     *  We calculate the stack to free when executing a reduction on
     *  the user stack, but we can not actually release the stack
     *  until control longjmps onto a runtime scheduling stack.
     *
     * This field is used to pass information to the runtime across
     * the longjmp onto the scheduling stack.
     *
     * [local read/write]
     */
    cilk_fiber* fiber_to_free;

    /**
     * Buckets for the memory allocator
     *
     * [local read/write]
     */
    struct free_list *free_list[FRAME_MALLOC_NBUCKETS];

    /**
     * Potential function for the memory allocator
     *
     * [local read/write]
     */
    size_t bucket_potential[FRAME_MALLOC_NBUCKETS];

    /**
     * Count indicates number of failures since last successful steal.  This is
     * used by the scheduler to reduce contention on shared flags.
     *
     * [local read/write]
     */
    unsigned int steal_failure_count;

    /**
     * Record indicating that the worker stole work at least once.
     *
     * [local read/write]
     */
    int has_stolen;
    
    /**
     * Separate the signal_node from other things in the local_state by the
     * sizeof a cache line for performance reasons.
     *
     * unused 
     */
    char buf[64];

    /**
     * Signal object for waking/sleeping the worker.  This should be a pointer
     * to avoid the possibility of caching problems.
     *
     * [shared read-only]
     */
     signal_node_t *signal_node;

    /** This value should be in the last field in any local_state */
#   define WORKER_MAGIC_1 ((ls_magic_t)0x16164afb0ea0dff9ULL)

    /**
     * Should be WORKER_MAGIC_1 or the local_state has been corrupted
     * This magic field is shared because it is read on lock acquisitions.
     * [shared read-only]
     */
    ls_magic_t worker_magic_1;
};