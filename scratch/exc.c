/*******************************************
 * Exceptions
 *******************************************/
/*
 * Cilk supports a clever way to send an interruption/exception to a
 * running worker, without interrupting its normal way of working. The
 * idea is as follows.
 *
 * The local worker operates at the bottom of the frame stack, using a
 * stack pointer T (tail).  The exception mechanism maintains another
 * pointer E (exception).  The worker polls the value of E when
 * decrementing T.  Whenever T becomes less or equal than E, the
 * worker calls the exception handler of the runtime system, that does
 * all the necessary bookkeeping.
 *
 * Exceptions can be sent only to running closures.  The exception
 * pointer is always greater or equal than the head pointer (the index
 * of the first non-stolen frame on the stack)
 */

/* value of E bigger than any possible value of T */
#define EXCEPTION_INFINITY (struct __cilkrts_stack_frame **)(-1LL)


static inline void 
increment_exception_pointer(struct __cilkrts_worker *const ws, 
                            struct __cilkrts_worker *const victim_ws, 
                            Closure *cl) {

    Closure_assert_ownership(ws, cl);
    CILK_ASSERT(ws, cl->status == CLOSURE_RUNNING);

    if(WS_EXCEPTION(victim_ws) != EXCEPTION_INFINITY) {
        ++WS_EXCEPTION(victim_ws);
        /* make sure the exception is visible, before we continue */
        Cilk_fence();
    }
}

static inline void 
decrement_exception_pointer(struct __cilkrts_worker *const ws, 
                            struct __cilkrts_worker *const victim_ws, 
                            Closure *cl) {

    Closure_assert_ownership(ws, cl);
    CILK_ASSERT(ws, cl->status == CLOSURE_RUNNING);

    if(WS_EXCEPTION(victim_ws) != EXCEPTION_INFINITY)
        --WS_EXCEPTION(victim_ws);
}

static inline void 
reset_exception_pointer(struct __cilkrts_worker *const ws, Closure *cl) {

    Closure_assert_ownership(ws, cl);
    CILK_ASSERT( ws, 
        (cl->frame == NULL) || 
        (cl->frame->worker == ws) || 
        (cl == USE_PARAMETER_WS(invoke_main) && 
         cl->frame->worker == (struct __cilkrts_worker *) NOBODY) );

    WS_EXCEPTION(ws) = WS_HEAD(ws);
}

/*
static inline void 
signal_immediate_exception(struct __cilkrts_worker *const ws, Closure *cl) {

    Closure_assert_ownership(ws, cl);
    CILK_ASSERT(ws, cl->status == CLOSURE_RUNNING);

    CLOSURE_EXCEPTION(cl) = EXCEPTION_INFINITY;
    // make sure the exception is visible, before we continue
    Cilk_fence();
}*/

static inline void 
signal_immediate_exception_to_all(struct __cilkrts_worker *const ws) {

    int i, active_size = USE_PARAMETER_WS(active_size);
    struct __cilkrts_worker *curr_ws;

    for(i=0; i<active_size; i++) {
        curr_ws = USE_PARAMETER_WS(workers)[i];
        WS_EXCEPTION(curr_ws) = EXCEPTION_INFINITY;
    }
    // make sure the exception is visible, before we continue
    Cilk_fence();
}

/*
 * This is the exception handler.
 * It returns 0 if the user code should continue execution
 * It returns 1 if the user code should return (back to caller) (aborting)
 * In the case of steal where parent frame is stolen, it long jmp back to
 * runtime stack and never return back to the user code.
 * 
 * We follow the protocol below:
 *
 *   reset exception pointer
 *   if ( H > T )
 *       it is a steal
 *       change state into CLOSRUE_RETURNING
 *       long jmp back to runtime 
 *
 *   else if (current frame is being aborted)
 *       res = 1
 *       signal another exception for parent frame
 *       if(current frame is the last frame)
 *            do a sync
 *            {suspend if needed; o.w. destroy frame and return}
 *       else
 *            destroy current frame
 *
 *   else {not steal, not abort}
 *       reset abort pointer to NO_ABORT
 *
 *   return res;
 */
/* 
 * ANGE: this is called from the user code (generated by compiler in cilkc)
 *       if Cilk_cilk2c_pop_check returns TRUE (i.e. E >= T).  Two 
 *       possibilities: 1. someone stole the last frame from this worker, 
 *       hence pop_check fails (E >= T) when child returns.  2. Someone 
 *       invokes signal_immediate_exception with the closure currently 
 *       running on the worker's deque.  This is only possible with abort.
 *       In Cilk-M, we use abort only if user invokes Cilk_exit to quit the
 *       program early.
 *
 *       If this function returns 1, the user code then calls 
 *       Cilk_cilk2c_before_return, which destroys the shadow frame and
 *       return back to caller. 
 */
void Cilk_exception_handler() {

    Closure *t;
    int res = 0;

    struct __cilkrts_worker *ws = tls->ws;

    Cilk_event(ws, EVENT_EXCEPTION);

    deque_lock_self(ws);
    t = deque_peek_bottom(ws, ws->self);

    CILK_ASSERT(ws, t);
#if DEBUG_VERBOSE
    Closure_lock_log(ws, t, EXCEPTION);
#else
    Closure_lock(ws, t);
#endif

    /* ANGE: resetting the E pointer since we are handling the exception */
    reset_exception_pointer(ws, t);

    CILK_ASSERT(ws, t->status == CLOSURE_RUNNING ||
                    // for during abort process
                    t->status == CLOSURE_RETURNING);

    if( WS_HEAD(ws) > WS_TAIL(ws) ) {
        Cilk_event(ws, EVENT_EXCEPTION_STEAL); // ANGE: this is a steal

        if(t->status == CLOSURE_RUNNING) {
            CILK_ASSERT(ws, Closure_has_children(t) == 0);
            t->status = CLOSURE_RETURNING;
        }

    } else if(Closure_being_aborted(ws, t)) { // ANGE: this is abort

CILK_ASSERT(ws, 0); // XXX for now. 
        Cilk_event(ws, EVENT_EXCEPTION_ABORT);
        struct __cilkrts_stack_frame *f, *next;
        struct __cilkrts_stack_frame *volatile*volatile head = WS_HEAD(ws);

        /* ANGE: we want to "unwind" the shadow frames, but sometimes the
           WS_TAIL can be NULL (if we spawn a function that hasn't
           created the frame yet, or if we spawn a C function), so we need
           to be careful */ 

        // ANGE: FIXME Need to check the abort logic. 
        // ANGE: we are not actually checking for exception unless the frame
        // is detached
        while( head != WS_TAIL(ws) ) {
            CILK_ASSERT(ws, *(WS_TAIL(ws)) == ws->current_stack_frame);
            f = ws->current_stack_frame;
            next = f->call_parent;
            if(f->flags & CILK_FRAME_DETACHED) {
                WS_TAIL(ws)--;
                ws->current_stack_frame = next;
            }

            // WHEN_CILK_DEBUG(f->magic = ~CILK_STACKFRAME_MAGIC);
            Cilk_destroy_frame_fast(ws, f);
        }

        CILK_ASSERT(ws, *(WS_TAIL(ws)) == ws->current_stack_frame);
        f = ws->current_stack_frame;

        while( __cilkrts_not_stolen(f) && 
               (f->flags & CILK_FRAME_DETACHED) == 0 ) {
            next = f->call_parent;
            // WHEN_CILK_DEBUG(f->magic = ~CILK_STACKFRAME_MAGIC);
            Cilk_destroy_frame_fast(ws, f);
            f = next;
        }

        if( t->frame == NULL ) {
            CILK_ASSERT(ws, f != NULL); 
            CILK_ASSERT(ws, __cilkrts_not_stolen(f) && 
                            (f->flags & CILK_FRAME_DETACHED) );
            // this can occur if we spawn a C function
            // or some function that does not create a frame (base case)
            __cilkrts_set_stolen(f);
            t->frame = f;
        } else {
            CILK_ASSERT(ws, t->frame == f);
            CILK_ASSERT(ws, __cilkrts_stolen(f));
        }

        // ANGE: Now Closure is at top of the stack (i.e. head == tail, and
        // there is only one frame in the top stacklet)
        CILK_ASSERT( ws, Closure_at_top_of_stack(ws) );

        if(Closure_has_children(t)) {
            Cilk_event(ws, EVENT_EXCEPTION_ABORT_SUSPEND);
            /* pretend to sync */
            Closure_suspend(ws, t);
        } else {
            // ANGE: now Closure is at top and has no children.
            // If this closure is not the root closure, we need to perform
            // the return protocol.  The closure may have either a call
            // parent or a spawn parent.  In either case, we let the
            // do_what_it_says handle it.  Note that, usually we only
            // perform return protocol when the closure is spawned.  The
            // only time we perform return protocol when the closure is
            // called is when we are aborting, since we are not returning
            // back to the user code.
            if( CLOSURE_ABORT(t) == ABORT_ALL ) {
                // WHEN_CILK_DEBUG(t->frame->magic = ~CILK_STACKFRAME_MAGIC);
                Cilk_destroy_frame(ws, t->frame);
                t->frame = (struct __cilkrts_stack_frame *) NULL;
                t->status = CLOSURE_RETURNING;
            } else {
                // If this closure is the root closure, we need to resume the
                // root closure (i.e., resume invoke_main), do clean up
                // at the end of invoke_main, and exit gracefully. 
                // assert that this is the root closure
                CILK_ASSERT(ws, t == USE_PARAMETER_WS(invoke_main)); 
                CILK_ASSERT(ws, CLOSURE_ABORT(t) == ALMOST_NO_ABORT);
                // The closure is already at the bottom of the deque
                // Just mark it ready and return back to runtime.
                reset_abort(t);
                // No need to reset stack here, because the closure we have
                // is the root closure (invoke_main).  It might have had been
                // stolen or it might not ... if it never got stolen, the
                // cl->num_of_pages would be 0.  In any case, we are about
                // to exit the problem so it doesn't really matter.
                ws->l->provablyGoodSteal = 1; // no need to remap stack
                Closure_make_ready(t);
            }
        }

    } else { // not steal, not abort; false alarm
        Cilk_event(ws, EVENT_EXCEPTION_OTHER);
        Closure_unlock(ws, t);
        deque_unlock_self(ws);

        return;
    }

    Closure_unlock(ws, t);
    deque_unlock_self(ws);
    goBackToRuntime(ws); // NOT returning back to user code
}
